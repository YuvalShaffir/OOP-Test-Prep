Type erasure is the process of replacing the generic type parameters
in a generic class or method with their bounding types or the Object type.
This process occurs during the compilation of Generics code, resulting in the removal of all
type information related to Generics at runtime. In simple terms, type erasure ensures
that the bytecode generated by the compiler is compatible with pre-existing code
that does not use Generics.

BYTECODE:

public class Erasure.equalization {
  public Erasure.equalization();
    Code:
       // Constructor
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       // Creating two ArrayList instances
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V <-- calling the ctor of
                                            // a class is a special call

       7: astore_1                          // Storing the reference to the first ArrayList
       8: new           #2                  // class java/util/ArrayList
      11: dup
      12: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
      15: astore_2                          // Storing the reference to the second ArrayList

      // Comparing the runtime classes of the ArrayList instances
      16: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
      19: aload_1
      20: invokevirtual #5                  // Method java/lang/Object.getClass:()Ljava/lang/Class;
      23: aload_2
      24: invokevirtual #5                  // Method java/lang/Object.getClass:()Ljava/lang/Class;

      // If the runtime classes are the same, print "true"
      27: if_acmpne     34
      30: iconst_1
      31: goto          35
      34: iconst_0
      35: invokevirtual #6                  // Method java/io/PrintStream.println:(Z)V

      // Printing the runtime class of the first ArrayList instance
      38: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
      41: aload_1
      42: invokevirtual #5                  // Method java/lang/Object.getClass:()Ljava/lang/Class;
      45: invokedynamic #7,  0              // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/Class;)Ljava/lang/String;
      50: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V

      // Printing the runtime class of the second ArrayList instance
      53: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
      56: aload_2
      57: invokevirtual #5                  // Method java/lang/Object.getClass:()Ljava/lang/Class;
      60: invokedynamic #9,  0              // InvokeDynamic #1:makeConcatWithConstants:(Ljava/lang/Class;)Ljava/lang/String;
      65: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      68: return
}
